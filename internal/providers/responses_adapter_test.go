package providers

import (
	"testing"

	"gomodel/internal/core"
)

func TestConvertResponsesRequestToChat(t *testing.T) {
	temp := 0.7
	maxTokens := 1024

	tests := []struct {
		name    string
		input   *core.ResponsesRequest
		checkFn func(*testing.T, *core.ChatRequest)
	}{
		{
			name: "string input",
			input: &core.ResponsesRequest{
				Model: "test-model",
				Input: "Hello",
			},
			checkFn: func(t *testing.T, req *core.ChatRequest) {
				if req.Model != "test-model" {
					t.Errorf("Model = %q, want %q", req.Model, "test-model")
				}
				if len(req.Messages) != 1 {
					t.Errorf("len(Messages) = %d, want 1", len(req.Messages))
				}
				if req.Messages[0].Role != "user" {
					t.Errorf("Messages[0].Role = %q, want %q", req.Messages[0].Role, "user")
				}
				if req.Messages[0].Content != "Hello" {
					t.Errorf("Messages[0].Content = %q, want %q", req.Messages[0].Content, "Hello")
				}
			},
		},
		{
			name: "with instructions",
			input: &core.ResponsesRequest{
				Model:        "test-model",
				Input:        "Hello",
				Instructions: "Be helpful",
			},
			checkFn: func(t *testing.T, req *core.ChatRequest) {
				if len(req.Messages) < 2 {
					t.Fatalf("len(Messages) = %d, want at least 2", len(req.Messages))
				}
				if req.Messages[0].Role != "system" {
					t.Errorf("Messages[0].Role = %q, want %q", req.Messages[0].Role, "system")
				}
				if req.Messages[0].Content != "Be helpful" {
					t.Errorf("Messages[0].Content = %q, want %q", req.Messages[0].Content, "Be helpful")
				}
			},
		},
		{
			name: "with parameters",
			input: &core.ResponsesRequest{
				Model:           "test-model",
				Input:           "Hello",
				Temperature:     &temp,
				MaxOutputTokens: &maxTokens,
			},
			checkFn: func(t *testing.T, req *core.ChatRequest) {
				if req.Temperature == nil || *req.Temperature != 0.7 {
					t.Errorf("Temperature = %v, want 0.7", req.Temperature)
				}
				if req.MaxTokens == nil || *req.MaxTokens != 1024 {
					t.Errorf("MaxTokens = %v, want 1024", req.MaxTokens)
				}
			},
		},
		{
			name: "with streaming enabled",
			input: &core.ResponsesRequest{
				Model:  "test-model",
				Input:  "Hello",
				Stream: true,
			},
			checkFn: func(t *testing.T, req *core.ChatRequest) {
				if !req.Stream {
					t.Error("Stream should be true")
				}
			},
		},
		{
			name: "array input with messages",
			input: &core.ResponsesRequest{
				Model: "test-model",
				Input: []interface{}{
					map[string]interface{}{
						"role":    "user",
						"content": "Hello",
					},
					map[string]interface{}{
						"role":    "assistant",
						"content": "Hi there!",
					},
				},
			},
			checkFn: func(t *testing.T, req *core.ChatRequest) {
				if len(req.Messages) != 2 {
					t.Fatalf("len(Messages) = %d, want 2", len(req.Messages))
				}
				if req.Messages[0].Role != "user" {
					t.Errorf("Messages[0].Role = %q, want %q", req.Messages[0].Role, "user")
				}
				if req.Messages[0].Content != "Hello" {
					t.Errorf("Messages[0].Content = %q, want %q", req.Messages[0].Content, "Hello")
				}
				if req.Messages[1].Role != "assistant" {
					t.Errorf("Messages[1].Role = %q, want %q", req.Messages[1].Role, "assistant")
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ConvertResponsesRequestToChat(tt.input)
			tt.checkFn(t, result)
		})
	}
}

func TestConvertChatResponseToResponses(t *testing.T) {
	resp := &core.ChatResponse{
		ID:      "chatcmpl-123",
		Object:  "chat.completion",
		Model:   "test-model",
		Created: 1677652288,
		Choices: []core.Choice{
			{
				Index: 0,
				Message: core.Message{
					Role:    "assistant",
					Content: "Hello! How can I help you today?",
				},
				FinishReason: "stop",
			},
		},
		Usage: core.Usage{
			PromptTokens:     10,
			CompletionTokens: 20,
			TotalTokens:      30,
		},
	}

	result := ConvertChatResponseToResponses(resp)

	if result.ID != "chatcmpl-123" {
		t.Errorf("ID = %q, want %q", result.ID, "chatcmpl-123")
	}
	if result.Object != "response" {
		t.Errorf("Object = %q, want %q", result.Object, "response")
	}
	if result.Model != "test-model" {
		t.Errorf("Model = %q, want %q", result.Model, "test-model")
	}
	if result.Status != "completed" {
		t.Errorf("Status = %q, want %q", result.Status, "completed")
	}
	if len(result.Output) != 1 {
		t.Fatalf("len(Output) = %d, want 1", len(result.Output))
	}
	if result.Output[0].Type != "message" {
		t.Errorf("Output[0].Type = %q, want %q", result.Output[0].Type, "message")
	}
	if result.Output[0].Role != "assistant" {
		t.Errorf("Output[0].Role = %q, want %q", result.Output[0].Role, "assistant")
	}
	if result.Output[0].Status != "completed" {
		t.Errorf("Output[0].Status = %q, want %q", result.Output[0].Status, "completed")
	}
	if len(result.Output[0].Content) != 1 {
		t.Fatalf("len(Output[0].Content) = %d, want 1", len(result.Output[0].Content))
	}
	if result.Output[0].Content[0].Type != "output_text" {
		t.Errorf("Content[0].Type = %q, want %q", result.Output[0].Content[0].Type, "output_text")
	}
	if result.Output[0].Content[0].Text != "Hello! How can I help you today?" {
		t.Errorf("Content[0].Text = %q, want %q", result.Output[0].Content[0].Text, "Hello! How can I help you today?")
	}
	if result.Usage == nil {
		t.Fatal("Usage should not be nil")
	}
	if result.Usage.InputTokens != 10 {
		t.Errorf("InputTokens = %d, want 10", result.Usage.InputTokens)
	}
	if result.Usage.OutputTokens != 20 {
		t.Errorf("OutputTokens = %d, want 20", result.Usage.OutputTokens)
	}
	if result.Usage.TotalTokens != 30 {
		t.Errorf("TotalTokens = %d, want 30", result.Usage.TotalTokens)
	}
}

func TestConvertChatResponseToResponses_EmptyChoices(t *testing.T) {
	resp := &core.ChatResponse{
		ID:      "chatcmpl-123",
		Object:  "chat.completion",
		Model:   "test-model",
		Created: 1677652288,
		Choices: []core.Choice{},
		Usage: core.Usage{
			PromptTokens:     10,
			CompletionTokens: 0,
			TotalTokens:      10,
		},
	}

	result := ConvertChatResponseToResponses(resp)

	if len(result.Output) != 1 {
		t.Fatalf("len(Output) = %d, want 1", len(result.Output))
	}
	// Content should be empty string when no choices
	if result.Output[0].Content[0].Text != "" {
		t.Errorf("Content[0].Text = %q, want empty string", result.Output[0].Content[0].Text)
	}
}

func TestExtractContentFromInput(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected string
	}{
		{
			name:     "string input",
			input:    "Hello world",
			expected: "Hello world",
		},
		{
			name: "array with text parts",
			input: []interface{}{
				map[string]interface{}{
					"type": "text",
					"text": "Hello",
				},
				map[string]interface{}{
					"type": "text",
					"text": "world",
				},
			},
			expected: "Hello world",
		},
		{
			name:     "nil input",
			input:    nil,
			expected: "",
		},
		{
			name:     "unsupported type",
			input:    12345,
			expected: "",
		},
		{
			name: "array with non-text parts",
			input: []interface{}{
				map[string]interface{}{
					"type": "image",
					"url":  "http://example.com/image.png",
				},
			},
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ExtractContentFromInput(tt.input)
			if result != tt.expected {
				t.Errorf("ExtractContentFromInput(%v) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}
