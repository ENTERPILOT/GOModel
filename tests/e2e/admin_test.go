//go:build e2e

package e2e

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"gomodel/internal/admin"
	"gomodel/internal/admin/dashboard"
	"gomodel/internal/providers"
	"gomodel/internal/server"
	"gomodel/internal/usage"
)

// setupAdminServer creates a new server instance with admin features configured.
func setupAdminServer(t *testing.T, masterKey string, endpointsEnabled, uiEnabled bool) *httptest.Server {
	t.Helper()

	// Create test provider using the shared TestProvider
	testProvider := NewTestProvider(mockLLMURL, "sk-test-key-12345")

	// Create registry and register mock provider with type
	registry := providers.NewModelRegistry()
	registry.RegisterProviderWithType(testProvider, "test")

	// Initialize registry synchronously for tests
	if err := registry.Initialize(context.Background()); err != nil {
		t.Fatalf("Failed to initialize registry: %v", err)
	}

	// Create router
	router, err := providers.NewRouter(registry)
	if err != nil {
		t.Fatalf("Failed to create router: %v", err)
	}

	// Build server config
	cfg := &server.Config{
		MasterKey:             masterKey,
		AdminEndpointsEnabled: endpointsEnabled,
	}

	if endpointsEnabled {
		cfg.AdminHandler = admin.NewHandler(nil, registry)
	}

	if uiEnabled {
		cfg.AdminUIEnabled = true
		dashHandler, dashErr := dashboard.New()
		if dashErr != nil {
			t.Fatalf("Failed to create dashboard handler: %v", dashErr)
		}
		cfg.DashboardHandler = dashHandler
	}

	srv := server.New(router, cfg)
	return httptest.NewServer(srv)
}

func TestAdminAPI_EndpointsEnabled_E2E(t *testing.T) {
	ts := setupAdminServer(t, "", true, false)
	defer ts.Close()

	endpoints := []string{
		"/admin/api/v1/usage/summary",
		"/admin/api/v1/usage/daily",
		"/admin/api/v1/models",
	}

	for _, ep := range endpoints {
		t.Run(ep, func(t *testing.T) {
			resp, err := http.Get(ts.URL + ep)
			require.NoError(t, err)
			defer closeBody(resp)

			assert.Equal(t, http.StatusOK, resp.StatusCode, "endpoint %s should return 200", ep)

			body, err := io.ReadAll(resp.Body)
			require.NoError(t, err)

			// Should be valid JSON
			assert.True(t, json.Valid(body), "response should be valid JSON for %s, got: %s", ep, string(body))
		})
	}
}

func TestAdminAPI_EndpointsDisabled_E2E(t *testing.T) {
	ts := setupAdminServer(t, "", false, false)
	defer ts.Close()

	endpoints := []string{
		"/admin/api/v1/usage/summary",
		"/admin/api/v1/usage/daily",
		"/admin/api/v1/models",
	}

	for _, ep := range endpoints {
		t.Run(ep, func(t *testing.T) {
			resp, err := http.Get(ts.URL + ep)
			require.NoError(t, err)
			defer closeBody(resp)

			assert.Equal(t, http.StatusNotFound, resp.StatusCode, "endpoint %s should return 404 when disabled", ep)
		})
	}
}

func TestAdminAPI_RequiresAuth_E2E(t *testing.T) {
	ts := setupAdminServer(t, testMasterKey, true, false)
	defer ts.Close()

	t.Run("without auth returns 401", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/api/v1/models")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusUnauthorized, resp.StatusCode)
	})

	t.Run("with valid auth returns 200", func(t *testing.T) {
		req, err := http.NewRequest(http.MethodGet, ts.URL+"/admin/api/v1/models", nil)
		require.NoError(t, err)
		req.Header.Set("Authorization", "Bearer "+testMasterKey)

		resp, err := http.DefaultClient.Do(req)
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)
	})
}

func TestAdminDashboard_Enabled_E2E(t *testing.T) {
	ts := setupAdminServer(t, "", true, true)
	defer ts.Close()

	t.Run("dashboard returns 200 HTML", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/dashboard")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)
		assert.Contains(t, resp.Header.Get("Content-Type"), "text/html")
	})

	t.Run("static CSS returns 200", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/static/css/dashboard.css")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)
	})
}

func TestAdminDashboard_Disabled_E2E(t *testing.T) {
	ts := setupAdminServer(t, "", true, false)
	defer ts.Close()

	resp, err := http.Get(ts.URL + "/admin/dashboard")
	require.NoError(t, err)
	defer closeBody(resp)

	assert.Equal(t, http.StatusNotFound, resp.StatusCode)
}

func TestAdminDashboard_SkipsAuth_E2E(t *testing.T) {
	ts := setupAdminServer(t, testMasterKey, true, true)
	defer ts.Close()

	t.Run("dashboard is public (200 without auth)", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/dashboard")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)
	})

	t.Run("API is protected (401 without auth)", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/api/v1/models")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusUnauthorized, resp.StatusCode)
	})
}

func TestAdminAPI_ModelsEndpoint_E2E(t *testing.T) {
	ts := setupAdminServer(t, "", true, false)
	defer ts.Close()

	resp, err := http.Get(ts.URL + "/admin/api/v1/models")
	require.NoError(t, err)
	defer closeBody(resp)

	assert.Equal(t, http.StatusOK, resp.StatusCode)

	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)

	var models []providers.ModelWithProvider
	require.NoError(t, json.Unmarshal(body, &models))

	// TestProvider returns 3 models
	assert.Len(t, models, 3)

	// Should be sorted by model ID
	for i := 1; i < len(models); i++ {
		assert.True(t, models[i-1].Model.ID < models[i].Model.ID,
			"models should be sorted, but %s >= %s", models[i-1].Model.ID, models[i].Model.ID)
	}

	// Each model should have provider_type
	for _, m := range models {
		assert.Equal(t, "test", m.ProviderType, "model %s should have provider_type 'test'", m.Model.ID)
	}
}

func TestAdminAPI_UsageEndpoints_E2E(t *testing.T) {
	ts := setupAdminServer(t, "", true, false)
	defer ts.Close()

	t.Run("summary returns zeroed object (nil reader)", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/api/v1/usage/summary")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)

		var summary usage.UsageSummary
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&summary))
		assert.Equal(t, 0, summary.TotalRequests)
		assert.Equal(t, int64(0), summary.TotalTokens)
	})

	t.Run("daily returns empty array (nil reader)", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/api/v1/usage/daily")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)

		body, err := io.ReadAll(resp.Body)
		require.NoError(t, err)

		var daily []usage.DailyUsage
		require.NoError(t, json.Unmarshal(body, &daily))
		assert.Empty(t, daily)
	})

	t.Run("query params accepted", func(t *testing.T) {
		resp, err := http.Get(ts.URL + "/admin/api/v1/usage/daily?days=7&interval=weekly")
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)
	})
}
