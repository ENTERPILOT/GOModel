//go:build e2e

package e2e

import (
	"encoding/json"
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"gomodel/internal/core"
)

func TestChatCompletion(t *testing.T) {
	t.Run("basic request", func(t *testing.T) {
		payload := core.ChatRequest{
			Model:    "gpt-4",
			Messages: []core.Message{{Role: "user", Content: "Hello, how are you?"}},
		}

		resp := sendChatRequest(t, payload)
		defer closeBody(resp)

		require.Equal(t, http.StatusOK, resp.StatusCode)

		var chatResp core.ChatResponse
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&chatResp))

		assert.NotEmpty(t, chatResp.ID)
		assert.Equal(t, "chat.completion", chatResp.Object)
		assert.Equal(t, "gpt-4", chatResp.Model)
		assert.Len(t, chatResp.Choices, 1)
		assert.Equal(t, "assistant", chatResp.Choices[0].Message.Role)
		assert.Equal(t, "stop", chatResp.Choices[0].FinishReason)
	})

	t.Run("conversation history", func(t *testing.T) {
		payload := core.ChatRequest{
			Model: "gpt-4",
			Messages: []core.Message{
				{Role: "system", Content: "You are a helpful assistant."},
				{Role: "user", Content: "What is 2+2?"},
				{Role: "assistant", Content: "4"},
				{Role: "user", Content: "And what is 3+3?"},
			},
		}

		resp := sendChatRequest(t, payload)
		defer closeBody(resp)

		require.Equal(t, http.StatusOK, resp.StatusCode)

		var chatResp core.ChatResponse
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&chatResp))
		assert.Contains(t, chatResp.Choices[0].Message.Content, "And what is 3+3?")
	})

	t.Run("empty messages", func(t *testing.T) {
		payload := core.ChatRequest{Model: "gpt-4", Messages: []core.Message{}}

		resp := sendChatRequest(t, payload)
		defer closeBody(resp)

		require.Equal(t, http.StatusOK, resp.StatusCode)
	})
}

func TestChatCompletionParameters(t *testing.T) {
	tests := []struct {
		name   string
		modify func(*core.ChatRequest)
	}{
		{
			name: "with temperature",
			modify: func(r *core.ChatRequest) {
				temp := 0.7
				r.Temperature = &temp
			},
		},
		{
			name: "with max_tokens",
			modify: func(r *core.ChatRequest) {
				maxTokens := 100
				r.MaxTokens = &maxTokens
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			payload := core.ChatRequest{
				Model:    "gpt-4",
				Messages: []core.Message{{Role: "user", Content: "Hello"}},
			}
			tt.modify(&payload)

			resp := sendChatRequest(t, payload)
			defer closeBody(resp)

			require.Equal(t, http.StatusOK, resp.StatusCode)

			var chatResp core.ChatResponse
			require.NoError(t, json.NewDecoder(resp.Body).Decode(&chatResp))
			assert.NotEmpty(t, chatResp.Choices[0].Message.Content)
		})
	}
}

func TestChatCompletionStreaming(t *testing.T) {
	t.Run("basic streaming", func(t *testing.T) {
		payload := core.ChatRequest{
			Model:    "gpt-4",
			Stream:   true,
			Messages: []core.Message{{Role: "user", Content: "Count from 1 to 5"}},
		}

		resp := sendChatRequest(t, payload)
		defer closeBody(resp)

		require.Equal(t, http.StatusOK, resp.StatusCode)
		assert.Equal(t, "text/event-stream", resp.Header.Get("Content-Type"))

		chunks := readStreamingResponse(t, resp.Body)
		require.Greater(t, len(chunks), 0)
		assert.True(t, chunks[len(chunks)-1].Done, "Last chunk should be [DONE]")
	})

	t.Run("streaming content", func(t *testing.T) {
		payload := core.ChatRequest{
			Model:    "gpt-4",
			Stream:   true,
			Messages: []core.Message{{Role: "user", Content: "Hello"}},
		}

		resp := sendChatRequest(t, payload)
		defer closeBody(resp)

		require.Equal(t, http.StatusOK, resp.StatusCode)

		chunks := readStreamingResponse(t, resp.Body)
		content := extractStreamContent(chunks)
		assert.NotEmpty(t, content)
	})
}

func TestChatCompletionErrors(t *testing.T) {
	t.Run("invalid JSON", func(t *testing.T) {
		resp, err := http.Post(gatewayURL+chatCompletionsPath, "application/json",
			strings.NewReader(`{"model": "gpt-4", "messages": invalid}`))
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusBadRequest, resp.StatusCode)
	})

	t.Run("missing model passthrough", func(t *testing.T) {
		// Test provider accepts all models, so empty model passes through
		resp := sendRawChatRequest(t, map[string]interface{}{
			"messages": []map[string]string{{"role": "user", "content": "Hello"}},
		})
		defer closeBody(resp)

		// Accept either OK (test provider) or BadRequest (production)
		assert.True(t, resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusBadRequest)
	})

	t.Run("invalid model passthrough", func(t *testing.T) {
		// Test provider accepts all models
		resp := sendRawChatRequest(t, map[string]interface{}{
			"model":    "invalid-model-xyz",
			"messages": []map[string]string{{"role": "user", "content": "Hello"}},
		})
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)
	})
}

func TestHealthAndModels(t *testing.T) {
	t.Run("health endpoint", func(t *testing.T) {
		resp, err := http.Get(gatewayURL + healthPath)
		require.NoError(t, err)
		defer closeBody(resp)

		assert.Equal(t, http.StatusOK, resp.StatusCode)

		var health map[string]string
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&health))
		assert.Equal(t, "ok", health["status"])
	})

	t.Run("list models", func(t *testing.T) {
		resp, err := http.Get(gatewayURL + modelsPath)
		require.NoError(t, err)
		defer closeBody(resp)

		require.Equal(t, http.StatusOK, resp.StatusCode)

		var modelsResp core.ModelsResponse
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&modelsResp))

		assert.Equal(t, "list", modelsResp.Object)
		assert.Greater(t, len(modelsResp.Data), 0)
	})
}

func TestChatCompletionConcurrency(t *testing.T) {
	const numRequests = 10

	type result struct {
		statusCode int
		err        error
	}
	results := make(chan result, numRequests)

	for i := 0; i < numRequests; i++ {
		go func(idx int) {
			payload := core.ChatRequest{
				Model:    "gpt-4",
				Messages: []core.Message{{Role: "user", Content: "Hello " + string(rune('A'+idx))}},
			}

			resp, err := sendJSONRequestNoT(gatewayURL+chatCompletionsPath, payload)
			if err != nil {
				results <- result{err: err}
				return
			}
			statusCode := resp.StatusCode
			closeBody(resp)
			results <- result{statusCode: statusCode}
		}(i)
	}

	// Collect all results in the main goroutine before asserting
	var errors []error
	successCount := 0
	for i := 0; i < numRequests; i++ {
		select {
		case r := <-results:
			if r.err != nil {
				errors = append(errors, r.err)
			} else if r.statusCode == http.StatusOK {
				successCount++
			}
		case <-time.After(30 * time.Second):
			t.Fatal("Timeout waiting for concurrent requests")
		}
	}

	// Perform all assertions in the main goroutine
	require.Empty(t, errors, "Expected no request errors")
	assert.Equal(t, numRequests, successCount)
}

func TestChatCompletionTimeout(t *testing.T) {
	client := &http.Client{Timeout: 10 * time.Second}

	payload := core.ChatRequest{
		Model:    "gpt-4",
		Messages: []core.Message{{Role: "user", Content: "Quick test"}},
	}

	body, _ := json.Marshal(payload)
	start := time.Now()
	resp, err := client.Post(gatewayURL+chatCompletionsPath, "application/json", strings.NewReader(string(body)))
	elapsed := time.Since(start)

	require.NoError(t, err)
	defer closeBody(resp)

	assert.Less(t, elapsed, 5*time.Second)
	assert.Equal(t, http.StatusOK, resp.StatusCode)
}
